
### 시각화하면 정확하게 보인다.

```
gapminder %>%
  filter(year == 2007) %>%
  ggplot(aes(gdpPercap, lifeExp)) +
  geom_point(aes(color = continent, size = pop)) +
  scale_x_log10()
```


선진국하고 후진국을 비교했을 때 선형구조를 가지고 있다는 것을 확인할 수 있다.
선형 모형으로 GDP를 사용한다고 하면은..
기대수명에 대해서 GDP가 어떠한 영향을 주는가 

어디에 태어나느냐에 따라서 
삶의 질, 길이 등이 결정된다. 


여러가지 요인들의 관계들을 시각화를 통해서 직관을 확보할 수 있다. 


mpg데이터에서 자동차 등급과 주행연비의 가ㅗㄴ계를
산점도와 상자그림으로 나타내십시오

compact   
midsize   
suv       
2seater   

minivan   
pickup    
subcompact




ifelse를 통해서 1과 0을 만들어서 넣을 수 있다. 



#### one hot encoding

col
a
b
a
b
a
c
b
위의 컬럼에서 유일한 것만 추출하면 

col_A col_B col_C
1       0       0
0       1       0
1       0       0
0       1       0
1       0       0
0       0       1
0       1       0


두 개만 가지고 3개 표현이 다가능하다. 
1 0일 때 B
0 1일 때 C
0 0이라면 A..!
이런 식으로 두 개만 있으면 작업이 가능하다. 




id컬럼을 제거하고, 로지스틱스 회귀분석을 이용한 분류
예측을 위해 악성(M)을 1로, 양성(B)을 0으로 변경한 후,
약성과 양성의 빈도를 구해봅시다. 


내가 레벨업하고.. 꼬셔야 된다..





#### nomalization, 정규화를 잘 해야...! 한다...!

데이터 전처리에 대한 영역
그래야 레벨업을 할 수 있다...! 

데이터 경진대회 같은 곳에서도 nomalization에 대한 수요가 일어나고 있다. 




## 0115

48.jar (java archive)

- java로 만들어진 프로그램을 압축해서 라이브러리 형태로 사용할 수 있다. 
- 다른 사람들에게 배포해서 사용하게 할 수 있다.
- jar 파일을 만들어서 export(외부로 배포하거나)
- jar 파일을 만들어서 import(library로 사용)할 수 있다.

49.import
- 다른 패키지에 있는 클래스 파일을 가져와서 사용할때 적용하는 문법이다.
- package 다음에 올 수 있다. 
- IDE에서 자동으로 추가를 해준다.
- 라이브러리를 추가하고 사용할 때도 import를 해줘야 라이브러리에 있는 
  파일을 사용할 수 있다.
- package명+클래스
  import edu.medici.magic.OddMagicSquare 
- 패키지에 있는 클래스를 다 가져오고 싶으면 *를 사용한다. 
  import edu.medici.magic.*;


#### 자료를 export 하고 import 하는 법

마방진 패턴을 찾으려고 했지만..! 
정답과 비교해 보면서 정답을 찾아가는데 실패한 이유를
찾아보고 비교분석을 해보자..!!


```java
for (int i = 0; i < top + 1; i++) {
  for (int j = 0; j < top+1; j++) {
    // System.out.print(magic[i][j]+ "\t");
    // 3 x 3 = 15
    // 5 x 5 = 
    if(magic[0][0]+magic[0][1]+magic[0][2] == 15) {
      System.out.println("검증 실패");
    }else if(magic[1][0]+magic[1][1]+magic[1][2] == 15) {
      System.out.println("검증 실패");
    }else if(magic[2][0]+magic[2][1]+magic[2][2] == 15) {
      System.out.println("검증 실패");
    }
    
    if(magic[0][0]+magic[1][0]+magic[2][0] == 15) {
      System.out.println("검증 실패");
    }
    if(magic[0][1]+magic[1][1]+magic[2][1] == 15) {
      System.out.println("검증 실패");
    }
    if(magic[0][2]+magic[1][2]+magic[2][2] == 15) {
      System.out.println("검증 실패");
    }
    
    if(magic[0][0]+magic[1][1]+magic[2][2] == 15) {
      System.out.println("검증 실패");
    }
    if(magic[0][2]+magic[1][1]+magic[2][0] == 15) {
      System.out.println("검증 실패");
    }
    
  }
}
```


50. 오버로딩(메소드 오버로딩)
똑같은데 파라미터가 다를 때..!
더 찾아보자 정보가 부족하다.

```java
public void eat(int bob)
public void eat(int bob)
public void eat(double bob)
```

51. 형변환(casting)
선생님 그림 찍은 거 비교해서 확인해보자!

부모는 자식의 모든 것을 받아주므로 다 받을 수 있다.
부모 이름으로 모든 것을 다 받을 수 있다. auto promotion, upcasting,암시적

자식은 필요한 것만 받는다. 빚은 안받고 돈, 차만 받는다.
자식은 부모가 주는 것을 자식의 형태로 맞추어야만 한다. down casting, 암시적

크기에 따라 안 받고, 받고가 결정된다. 


52. oop 용어
parent,super 
extends
child, sub

추상화 구체화..!

53. boxing / unboxing
- boxing : 기본타입을 참조타입으로 바꾸는 것

```java
int a = 10; 
Integer aa = new Integer(a); //기 -> 참
Integer aa2 = 10; // 기 -> 참
int c = aa2; // 참 -> 기
```

커피랑 초콜릿은 자체는 기본타입,

작업을 해야 값을 확인할 수 있다.
박싱은 기본타입을 참조타입으로 ..!
언박싱은 참조타입을 기본타입으로 바꾸는 것...!


54. Wrapper Class

- 참조타입을 기본타입으로 바꿀 때 사용하는 클래스 
- 기본타입 앞의 글자를 대문자로 만들면 클래스명이 된다. 이러한 클래스가 있다
- 기본타입을 참조로, 참조를 기본타입으로 바꿀 때 사용한다. 

Boolean
Byte
Character
Short 
Integer
Long
Float
Double

55. Integer.parseInt();
- 문자열을 int형으로 변환할 때 사용하는 Wrapper class 메소드
- int passwd = Integer.parseInt("12345")

56. static/non-static

객체를 생성하거나, static 키워드를 붙인다. 
결국은 메모리에 올린다는 이야기


부모 자식관계에서 부모에 있는 메소드와
자식에 있는 메소드가 동일하면 
자식의 메소드를 호출하는 것
자식의 메소드가 호출되는 것

57. overriding(오버라이딩)

부모 메서드랑 자식 메서드가 동일하면
자식메서드가 호출된다.

58. java.lang.Object 의 4대 메소드

- boolean equals(Object o):
  객체끼리 같은지를 판단할 때 사용하는 메소드 
```
A a = new A();
A a2 = new A();
```

- String toString();
  문자열 타입으로 변경시켜주는 메소드



- int hashcode();
  객체의 해쉬코드를 가져오는 메소드

- Class getClass();
  객체의 package명 + 클래스 이름을 가져오는 클래스 타입의 메소드
  edu.medici.magic.OddMagicSquare


와아아아아ㅇ와ㅗ


```java
@Override
public String toString() {
  return super.toString() + "Student [sId=" + sId + ", subjects=" + subjects + "]";
}

public Student() {} // 오버로딩하면 디폴트 생성자는 무조건 만든다.
public Student(String name,int age, String sId, String subjects) {
  super(name, age);
  this.sId = sId;
  this.subjects = subjects;
}
public String getsId() {
  return sId;
}
public void setsId(String sId) {
  this.sId = sId;
}
public String getSubjects() {
  return subjects;
}
public void setSubjects(String subjects) {
  this.subjects = subjects;
}

```



```java
package edu.medici.overriding;

public class Teacher extends People {
	
	private String tId;
	private String tSubject;
	
	
	@Override
	public String toString() {
		return super.toString() + "Teacher [tId=" + tId + ", tSubject=" + tSubject + "]";
	}
	public Teacher() {}
	public Teacher(String name, int age, String tId, String tSubject) {
		super(name, age);
		this.tId = tId;
		this.tSubject = tSubject;
	}
	public String gettId() {
		return tId;
	}
	public void settId(String tId) {
		this.tId = tId;
	}
	public String gettSubject() {
		return tSubject;
	}
	public void settSubject(String tSubject) {
		this.tSubject = tSubject;
	}
	
	
}
```


```java
public static void main(String[] args) {
  // TODO Auto-generated method stub
  People p = new People("아이폰", 2);
  
  // p.
  
  System.out.println(p.toString());
  
  Student s = new Student("임성태", 14, "202001","웹프로그래밍");
  
  System.out.println(s); // 내것만 출력됨..!
  
  // String tId
  // String tSubject
  Teacher t = new Teacher("한혜진", 20, "202002", "Acting");
  System.out.println(t);
}
```

