# REST



## Table of Contents

1. **[REST 정의](#REST-정의)**
1. **[REST의 제약 조건](#REST의-제약-조건)**

---



## REST 정의

2000년 로이 필딩은 '건축 양식 및 네트워크 기반 소프트웨어 아키텍처 설계'라는 박사학위 논문에서 REST를 소개했고, 이는 HTTP 1.1 및 URI(Uniform Resource Identifiers) 표준을 설계하는 데 이용됐다.

> REST는 웹 서비스 생성에 사용되는 일련의 제약 조건을 정의하는 소프트웨어 아키텍쳐 스타일이다.

## REST의 제약조건

로이필딩이 소개한 REST 아키텍처에 적용되는 제약조건은 다음과 같다.

### **첫째, 클라이언트-서버**

**클라이언트와 서버의 분리를 의미**한다. 클라이언트와 서버 각각의 애플리케이션은 서로 어떠한 종속적인 제약 없이 독립적으로 업데이트 될 수 있어야 한다.

- **클라이언트**는 자원의 URIs(Uniform Resource Identifiers)만 필요로 함
- **서버**는 단순화해 확장성을 향상시킨다.

### **둘째, Statelessness**

REST의 가장 중요한 조건은 **서버에 클라이언트의 상태를 저장하지 않아야 한다는 것**이다. 이 말은 클라이언트의 요청(request)은 모두 새로운 요청이라는 의미이다.

- 클라이언트에서 서버로 요청시 서버가 이해할 수 있는 모든 정보를 포함해 요청하고, 서버는 이에 응답함
- 만일 클라이언트 애플리케이션에서 사용자에게 인증 같은 부분이 필요하다면, 서버에 요청할 때 인증 정보를 포함해 요청해야 함

### **셋째, 캐시 능력**

서버에서 **클라이언트에 대한 응답은 캐시 가능해야 한다는 것을 의미**한다. 여기서 **캐시는 클라이언트 자체에 서버 응답을 저장하는 것**을 말하며, 클라이언트에서 요청하고 서버에서 응답하는 과정은 상당한 시간을 필요로 한다. 따라서 이전에 가져온 리소스를 캐시했다가 재활용할 수 있도록 하는 것은 성능을 향상시키는 데 유용하다. 기본적으로 최신 브라우저에는 Expires, Cache-Control, Etag, Last-Modified 같은 캐시 시능을 제공한다.

### **넷째, Layered System**

클라이언트에서 서버로 요청하면 REST 서버는 요청에 대한 응답을 클라이언트로 보내게 되는데 **클라이언트와 서버 사이에는 보안, 로드 밸런싱 계층 등이 존재할 수 있다는 것을 나타낸다**. 이를 통해 클라이언트에서는 최종 서버에 연결돼 있는지 중간에 다른 서버를 거쳐서 연결되는지 알 수 없도록 한다.

### **다섯쨰, Uniform Interface**

네트워크 시스템에서 **클라이언트와 서버 간의 인터페이스를 정의**하는 데 사용되며 4가지의 가이드라인을 제공한다.

#### **1. 자원 식별**

**자원은 요청을 통해 식별**된다.

예를 들어 웹 기반 REST 서비스에서는 자원을 고유하게 식별하고 위치를 지정하는 데 `URI(Uniform Resource Identifier)`를 이용한다. 여기서 자원은 **REST**에서 중요한 데이터 표현(Representation)이다. 이미지, 문서, contracts 같은 집합 형태, 사람 같은 비가상 객체의 경우도 자원이 될 수 있다. 예를 들어 한 명의 고객을 나타내는 customer, 두 명 이상의 고객을 나타내는 customers라는 자원이 있을 때 이를 URI를 이용해서 나타내면 다음과 같다.


```markdown
`customers`와 같이 집합 형태일 경우 - /customers/ 
`customer`와 같이 단수 형태일 경우 - /customers/{customerId}
```

자원은 하위 자원을 포함할 수도 있다. 예를 들어 은행 계좌를 한 개 혹은 두 개 이상 가지고 있을 수 있는 경우 `URI(Uniform Resource Identifier)`를 이용해서 나타내면 다음과 같다.

```markdown
- /customers/{customerId}/accounts
- /customers/{customerId}/accounts/{accountId}
```

`URI`를 이용해 잘 정의된 자원은 직관적이어서 사용하기 편리하다.

#### **2. Manipulation of resources through representations**

- 클라이언트는 자원을 조작할 때 필요한 자원의 표현을 포함해 해당 자원을 조작을 서버에 요청
- 일반적으로 자원의 표현은 JSON 형식으로 이루어짐
- 서버는 HTTP 메서드와 URI를 이용해 자원에 CRUD를 실행

#### **메서드의 기능 표**

| 메서드 | 기능                                 | 성공     | 실패    |
| ------ | ------------------------------------ | -------- | ------- |
| GET    | 하나의 리소스나 다수의 리소스를 검색 | 200      | 404     |
| POST   | 하나의 리소스나 다수의 리소스를 생성 | 201      | 404,409 |
| PUT    | 특정 리소스를 수정하거나 대체        | 200, 204 | 404     |
| DELETE | 특정 리소스를 삭제                   | 200      | 404     |



#### **3. 자기 설명적 메시지(Self-descriptive Messages)**

- 각 클라이언트 요청 및 서버 응답은 하나의 메시지이지만 각 메시지는 자체적으로 설명할 수 있어야 한다.  즉, 각 **메시지에는 작업을 완료하는데 필요한 모든 정보가 포함돼야 한다**는 의미
- 간단한 예로 만일 한 제품에 대한 자원이 제품코드, 이름, 가격으로 구성된다면 JSON, XML로 다음과 같이 나타낼 수 있음

```json
{
	"code": "p001",
	"name": "smartphone",
	"price": 850000
}
```

```xml
<product>
	<code>p001</code>
  <name>smartphone</name>
  <price>850000</price>
</product>
```



#### **4. HATEOAS(Hypermedia as The Engine of Application State)**

**서버의 응답에 하이퍼 미디어 링크를 사용하고 클라이언트가 하이퍼 미디어 링크를 탐색해 해당 자원을 동적으로 탐색할 수 있도록 한다**. 여기서 하이퍼 미디어(Hypermedia)는 이미지, 영화 및 텍스트와 같은 다른 형식의 미디어에 대한 링크가 포함된 모든 콘텐츠를 나타낸다.



### 여섯째, Code on Demand(optional)

대부분의 경우 서버로부터 받는 응답은 `JSON`이거나 `XML`이지만 **때때로 자바스크립트 코드처럼 실행 가능한 응답을 받아야 할 수 있다**. 예를 들어 클라이언트는 서버에 코드를 요청할 수 있고. 응답이 HTML일 때 보통 스크립트 형식의 일부 코드가 포함되며, 클라이언트는 해당 코드를 실행할 수 있다.

# RESTful 웹서비스

**REST에서 정의한 일련의 제약 조건을 따르는 웹서비스**를 **RESTful 웹 서비스**라고 부른다. RESTful 웹서비스는 가볍고 빠르면서도 확장 가능하며, 유지보수가 편리하다.

## 장점

- 기존의 HTTP의 `methods`를 사용하므로 자원을 조작할 때 추가적인 작업이 필요 없음
- `JSON`, `XML`, `HTML`과 같이 다양한 파일 타입을 지원
- 배우기 쉽고, 사용하기 편리
- 캐싱 기능을 제공해 성능 향상을 기대할 수 있음

## 단점

- 사용할 수 있는 HTTP `methods`가 제한적이다.
- 앞서 **REST의 6가지의 제약 조건**은 **RESTful 웹 서비스**를 구축하는 가이드 라인을 제시한 것이지 반드시 지켜야 할 사항은 아니므로 **표준이 존재하지 않는다.**

